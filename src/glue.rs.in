use crate::*;
use jni_sys::*;

foreign_class!(
    class Moves {
        self_type Moves;

        constructor default() -> Moves {
            Vec::<WrapperMove>::default()
        }

        fn at(&self, i: usize) -> WrapperMove {
            this[i].clone()
        }

        fn len(&self) -> u32 {
            this.len() as u32
        }
    }
);
foreign_class!(
    class Cells {
        self_type Cells;

        constructor default() -> Cells {
            Vec::<WrappedCell>::default()
        }

        fn at(&self, i: usize) -> WrappedCell {
            this[i].clone()
        }

        fn len(&self) -> u32 {
            this.len() as u32
        }
    }
);
foreign_enum!(
	enum GlobalMatchState {
		Error = GlobalMatchState::Error,
		Unconnected = GlobalMatchState::Unconnected,
		Connecting = GlobalMatchState::Connecting,
		WaitingOpponent = GlobalMatchState::WaitingOpponent,
		GameInProgress = GlobalMatchState::GameInProgress,
		Canceled = GlobalMatchState::Canceled,
		Finished = GlobalMatchState::Finished,
	}
);
foreign_callback!(
	callback StateObserver {
		self_type StateObserver;
		onStateChanged = StateObserver::on_state_changed(& self , state : GlobalMatchState);
	}
);

foreign_enum!(
	enum Color {
		Black = Color::Black,
		White = Color::White,
	}
);
foreign_enum!(
	enum PieceType {
		Pawn = PieceType::Pawn,
		Knight = PieceType::Knight,
		Bishop = PieceType::Bishop,
		Rook = PieceType::Rook,
		Queen = PieceType::Queen,
		King = PieceType::King,
		Invalid = PieceType::Invalid,
		EmptySquare = PieceType::EmptySquare,
	}
);
foreign_enum!(
	enum GameStatus {
		Finished = GameStatus::Finished,
		MoveWhite = GameStatus::MoveWhite,
		MoveBlack = GameStatus::MoveBlack,
		DistantMoveWhite = GameStatus::DistantMoveWhite,
		DistantMoveBlack = GameStatus::DistantMoveBlack,
	}
);
foreign_enum!(
	enum MoveState {
		MyMove = MoveState::MyMove,
		MoveValidation = MoveState::MoveValidation,
		OpponentMove = MoveState::OpponentMove,
	}
);

foreign_class!(
	class WrappedCell {
		self_type WrappedCell;
		private constructor = empty;
		fn WrappedCell::hidden(& self)->bool; alias hidden;
		fn WrappedCell::has_figure(& self)->bool; alias hasFigure;
		fn WrappedCell::kind(& self)->PieceType; alias kind;
		fn WrappedCell::color(& self)->Color; alias color;
		fn WrappedCell::impose_check(& self)->bool; alias imposeCheck;
		fn WrappedCell::can_move(& self)->bool; alias canMove;
	}
);
foreign_class!(
	class WrapperMove {
		self_type WrapperMove;
		private constructor = empty;
		fn WrapperMove::to_rank(& self)->u32; alias toRank;
		fn WrapperMove::to_file(& self)->u32; alias toFile;
		fn WrapperMove::from_rank(& self)->u32; alias fromRank;
		fn WrapperMove::from_file(& self)->u32; alias fromFile;
	}
);
foreign_class!(
	class WrapperGame {
		self_type WrapperGame;
		constructor WrapperGame::new()->WrapperGame;
		fn WrapperGame::make_move(& mut self , _move : WrapperMove)->GameStatus; alias makeMove;
		fn WrapperGame::possible_moves(& self , rank : usize , file : usize)->Moves; alias possibleMoves;
		fn WrapperGame::board(& self)->Cells; alias board;
		fn WrapperGame::current_player(& self)->Color; alias currentPlayer;
		fn WrapperGame::checked(& self)->bool; alias checked;
		fn WrapperGame::game_ended(& self)->bool; alias gameEnded;
	}
);
foreign_class!(
	class OnlineGame {
		self_type OnlineGame;
		constructor OnlineGame::new()->OnlineGame;
		fn OnlineGame::install_observer(& mut self , observer : Box < dyn StateObserver >); alias installObserver;
		fn OnlineGame::connect(& mut self , url : String); alias connect;
		fn OnlineGame::send_move(& mut self , _move : WrapperMove); alias sendMove;
		fn OnlineGame::check_state(& mut self); alias checkState;
		fn OnlineGame::player(& self)->Color; alias player;
		fn OnlineGame::current_player(& self)->Color; alias currentPlayer;
		fn OnlineGame::sub_state(& self)->MoveState; alias subState;
		fn OnlineGame::possible_moves(& self , rank : usize , file : usize)->Moves; alias possibleMoves;
		fn OnlineGame::board(& self)->Cells; alias board;
	}
);

